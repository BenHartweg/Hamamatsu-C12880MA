//v5 experimental - BH
//changelog: 
//----------------
//v5.1: 
//adapted for SPI use of external ADC (MCO33121-05 / 10), wip
//
//----------------
//based on Code by Urs Utzunger, 2020;
//git: https://github.com/uutzinger/C12880MA

//libraries to include
#include <Arduino.h>
#include <SPI.h>
#include <vector>

//------------------------------------------------------------------------------------------------------
//Teensy PIN declarations
//------------------------------------------------------------------------------------------------------
//µc outputs
#define S_CLK     23    //used in CLK gen
#define S_ST      18    //for opening the register and ctrl integ times; ST Pulse
#define ADC_SLAVE 10

//µc inputs
#define S_TRG     14    //input coming from spectrometer, used to time extADC and SPI
#define S_EOS     16    //end-of-scan signal generated by spec
#define S_CCount  21    //CLK pulse counter, used for timings and progress, INT_pin for counting

//other definitions
#define C12880_NCA 288  //number of channels

// USB Serial use
#define mySerial Serial
#define BAUDRATE 115200


//------------------------------------------------------------------------------------------------------
//std variables
//------------------------------------------------------------------------------------------------------

// SPI Serial Use
const uint32_t SPI_CLK = 10E6;
SPISettings settingsA(SPI_CLK, MSBFIRST, SPI_MODE0); 
uint16_t MSB, LSB; //init variables for SPI ADC data


//cpu and clk settings
//uint32_t CLK_Pin = S_CLK; //why redefine?
uint32_t CPU_Fqz = F_CPU/1E6;

// setting the clock
uint32_t CLK_Freq = 200000;
uint32_t PWM_MaxFreq;
int PWM_Resolution = 2; //minimum at int 2
uint16_t PWM_MaxVal;
float PWM_Duty = 50.0;

float integTime = 1/1E3; //setting the integration time in [ms]


//prepare the spectrum 
std::vector<uint16_t> spectrum(C12880_NCA+1); //unsure about the +1, tbd

//slow down the whole program for easier USB serial readings
uint16_t delTime = 10; //ns


//------------------------------------------------------------------------------------------------------
//ISR variables
//------------------------------------------------------------------------------------------------------

//cases for code_runner
enum states {preStart, startST, stopST, preRead, Read, Holding, Send};

// ISR variables
volatile long int count = 0; //counter for code runner and shifting ops phase

volatile states myState = Holding; 
volatile bool spectrumReady = false; 

//calculate the integ Counts used in 
volatile long int integCounts = uint32_t(integTime*float(CLK_Freq)) - 45;

//ident for loop in saving data
volatile int position = 0;

//just to test
volatile uint8_t i = 0;


//----------------------------------------------------------------------------------------------------
// CLK Signal generation function
//----------------------------------------------------------------------------------------------------

void CLK_gen () {
    PWM_MaxVal = pow(2, PWM_Resolution);

    analogWriteResolution(PWM_Resolution);
    analogWriteFrequency(S_CLK, CLK_Freq);
    analogWrite(S_CLK, uint16_t(PWM_Duty*PWM_MaxVal/100.0));
}

//----------------------------------------------------------------------------------------------------
// Data 
//----------------------------------------------------------------------------------------------------

//read spectrum

std::vector<uint16_t> ReadData (std::vector<uint16_t> spectrum,  int position) {

  digitalWriteFast(ADC_SLAVE, LOW);
  MSB = SPI.transfer(0XFF); //send  0XFF = 255, so rx only
  LSB = SPI.transfer(0XFF);
  
  uint16_t iVal = (((uint16_t)MSB << 8) | LSB);
  iVal = iVal >> 2; //to obtain 14 bit data
  digitalWriteFast(ADC_SLAVE, HIGH);
  
  spectrum.at(position) = iVal; 
  position++;
  return spectrum;  
}


//send spectrum

void transmitSpectrum(std::vector<uint16_t> spectrum) {
  
    size_t i; 

    for (i = 0 ; i < C12880_NCA; i++) 
    {
        mySerial.printf("%d, ", spectrum.at(i));
    }
mySerial.write('\n');

}


//----------------------------------------------------------------------------------------------------
// ISR functions
//----------------------------------------------------------------------------------------------------
// Code Runner ISR / -> ISR on the rising flank of S_CCount = CLK
//----------------------------------------------------------------------------------------------------

void CodeRunner() {
    count--; //count is reduced by 1 on every ISR trigger, so everytime S_CCount rises
      
    if (count <= 0){
    switch(myState)
    {
      case Holding:
      //just do nothing
      break; 

      case preStart:
      myState = startST;
      count = 1; //performs the two clocks before setting ST to high
      break; 

      case startST:
      digitalWriteFast(S_ST, HIGH);
      myState = stopST; 
      count = integCounts; //equals 3+integrationTime in Counts -48
      break;

      case stopST:
      digitalWriteFast(S_ST, LOW);
      myState = preRead;
      count = 88; //equals 48 remaining clks after ST goes low, and add 40 clks until vid appears, see datasheet for reference
      break; 

      case preRead:
      //enable ADC
      myState = Read;
      count = C12880_NCA;
      break; 

      case Read:
      //complete ADC
      myState = Holding;
      break;

      default:
      break; 
        }
    }
}

//----------------------------------------------------------------------------------------------------
// EOS ISR; rising (rising once, each time all channels have been meassured by spectrometer)
//----------------------------------------------------------------------------------------------------

void EOS_isr(){
spectrumReady = true; 
i = 0;

}

//----------------------------------------------------------------------------------------------------
// ST ISR; falling (falling once each meassuremtn/setting of integ time)
//----------------------------------------------------------------------------------------------------

void STfall_isr(){
    spectrumReady = false; 
    
}

//----------------------------------------------------------------------------------------------------
// TRG ISR; falling (on each clock+ 180 phase shift)
//----------------------------------------------------------------------------------------------------

void TRGfall_isr(){
    
if (spectrumReady == false && myState == Read)
{
    //actual data reading


    // ReadData(spectrum, position);

    //just to test, wether anything is actually working 
    spectrum.at(1) = 7;
} 

}

//----------------------------------------------------------------------------------------------------
// GetMaxPWMFqz
//----------------------------------------------------------------------------------------------------

float GetMaxPWMFreqValue(uint32_t FREQ, uint16_t PWM_Resolution)
{
  /* for Teensy 3.x CPU frequency 24MHZ 48MHZ 72MHZ 96MHZ 120MHZ  */
  int FREQ_pointer=-1;
  float PWM_ideal_frequency[5][15]
  {
    { 6000000, 3000000, 1500000,  750000, 375000, 187500,  93750,  46875  , 23437.5 , 11718.75 ,  5859.375, 2929.687, 1464.843,  732.421, 366.2109},
    {12000000, 6000000, 3000000, 1500000, 750000, 375000, 187500,  93750  , 46875   , 23437.5  , 11718.75 , 5859.375, 2929.687, 1464.843, 732.4218},
    { 9000000, 4500000, 2250000, 1125000, 562500, 281250, 140625,  70312  , 35156.25, 17578.12 ,  8789.062, 4394.531, 2197.265, 1098.632, 549.3164},
    {12000000, 6000000, 3000000, 1500000, 750000, 375000, 187500,  93750  , 46875   , 23437.5  , 11718.75 , 5859.375, 2929.687, 1464.843, 732.4218},
    {15000000, 7500000, 3750000, 1875000, 937500, 468750, 234375, 117187.5, 58593.75, 29296.875, 14648.537, 7324.219, 3662.109, 1831.055, 915.527 }
  };
  switch(FREQ){
    case 24:  FREQ_pointer=0;  break;
    case 48:  FREQ_pointer=1;  break;
    case 72:  FREQ_pointer=2;  break; 
    case 96:  FREQ_pointer=3;  break; 
    case 120: FREQ_pointer=4;  break;          
    default:  FREQ_pointer=-1; break;          
  }
  if (FREQ_pointer >= 0) { return(PWM_ideal_frequency[FREQ_pointer][PWM_Resolution-2]); }
  else {                   return(488.28); }
} // end getMaxPWMFreqValue


//----------------------------------------------------------------------------------------------------
// Setup
//----------------------------------------------------------------------------------------------------

void setup () {
    while (millis() < 100) ;
    mySerial.begin(BAUDRATE);
    mySerial.setTimeout(1);    


// set pins and pre states 

//out
pinMode(S_CLK, OUTPUT);
pinMode(S_ST, OUTPUT);
pinMode(ADC_SLAVE, OUTPUT);

//in
pinMode(S_TRG, INPUT);
pinMode(S_EOS, INPUT);
pinMode(S_CCount, INPUT);

// states
digitalWriteFast(S_ST, LOW);
digitalWriteFast(S_CLK, LOW);
digitalWriteFast(ADC_SLAVE, HIGH);


//ISR Trigg
attachInterrupt(S_CCount, CodeRunner, RISING);
attachInterrupt(S_EOS, EOS_isr, RISING);
attachInterrupt(S_ST, STfall_isr, FALLING);
attachInterrupt(S_TRG, TRGfall_isr, FALLING);

// start the clk
CLK_gen();

count = 1; 
myState = Holding;

}//end of setup



//----------------------------------------------------------------------------------------------------
// Loop
//----------------------------------------------------------------------------------------------------

void loop () {

    if((myState == Holding) && (spectrumReady == false)) {
        myState = preStart;
    }
    if (spectrumReady == true) {
       transmitSpectrum(spectrum);
       spectrumReady = false; 
       delay(100);

    }
}


