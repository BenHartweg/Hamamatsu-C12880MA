//v4 - BH
//based on Code by Urs Utzunger, 2020
//git: https://github.com/uutzinger/C12880MA
//an edited ADC lib with external trg capacities is needed, also provided by uutzinger
//see: https://github.com/uutzinger/ADC


//libraries to include
#include <Arduino.h>
#include <ADC.h>
#include <DMAChannel.h>

//Teensy PIN declarations
//µc outputs
#define S_CLK     23    //used in CLK gen
#define S_ST      18    //for opening the register and ctrl integ times; ST Pulse

//µc inputs
#define S_TRG     11    //must be on pin 11, see ADC lib
#define S_Video   14    //input capturing, low impedance, use op amp
#define S_EOS     16    //end-of-scan signal generated by spec
#define S_CCount  21    //CLK pulse counter, used for timings and progress, INT_pin for counting

//other definitions
#define C12880_NCA 288  //number of channels

// USB Serial use
#define mySerial Serial
#define BAUDRATE 115200


// volatile variables for ISR use

//cases for code_runner
enum states {preStart, startST, stopST, preRead, Read, Holding, Send};

// ISR variables
volatile long int count = 0; //counter for code runner and shifting ops phase
//volatile long int integCounts = 0; //integTime translated to actual counts in program 
volatile uint32_t pdbticks, adcticks, adcval, last_read;
volatile states myState = Holding; 
volatile bool ADC_HS = true; //wether high speed is enabled or not
volatile bool spectrumReady = false; 

// CPU settings

//uint32_t CLK_Pin = S_CLK; //why redefine?
uint32_t CPU_Fqz = F_CPU/1E6;

// setting the clock
uint32_t CLK_Freq = 200000;
uint32_t PWM_MaxFreq;
int PWM_Resolution = 2; //minimum at int 2
uint16_t PWM_MaxVal;
float PWM_Duty = 50.0;

// std variables for non ISR use

float integTime = 1/1E3; //setting the integration time in [ms]


// calculate integration time counts

volatile long int integCounts = uint32_t(integTime*float(CLK_Freq)) - 45;

// ADC and DMA Settings

ADC *adc = new ADC(); //call the main class adc
DMAChannel dma0;
DMAMEM static uint16_t spectrum[C12880_NCA+88+1]; //set the DMA buffer to be used

//----------------------------------------------------------------------------------------------------
// CLK Signal generation function
//----------------------------------------------------------------------------------------------------

void CLK_gen () {
    PWM_MaxVal = pow(2, PWM_Resolution);

    analogWriteResolution(PWM_Resolution);
    analogWriteFrequency(S_CLK, CLK_Freq);
    analogWrite(S_CLK, uint16_t(PWM_Duty*PWM_MaxVal/100.0));
}


//----------------------------------------------------------------------------------------------------
// Code Runner ISR
//----------------------------------------------------------------------------------------------------

void CodeRunner() {
    count--; //count is reduced by 1 on every ISR trigger, everytime S_CCount rises
  
    
    if (count <= 0){
    switch(myState)
    {
      case Holding:
      //just do nothing
      break; 

      case preStart:
      myState = startST;
      count = 1; //performs the two clocks before setting ST to high
      break; 

      case startST:
      digitalWriteFast(S_ST, HIGH);
      myState = stopST; 
      count = integCounts; //equals 3+integrationTime in Counts -48
      break;

      case stopST:
      digitalWriteFast(S_ST, LOW);
      myState = preRead;
      count = 88; //equals 48 remaining clks after ST goes low, and add 40 clks until vid appears, see datasheet for reference
      break; 

      case preRead:
      //enable ADC
      myState = Read;
      count = C12880_NCA;
      break; 

      case Read:
      //complete ADC
      myState = Holding;
      break;

      default:
      break; 
        }
    }
}


//----------------------------------------------------------------------------------------------------
// DMA ISR; called, when the DMA buffer is full
//----------------------------------------------------------------------------------------------------

void dma0_isr(){
    dma0.clearInterrupt();
    dma0.clearComplete();
}

// ?? check, actually not needed when using dma acc to uu
void adc0_isr() {
  adcticks++;
  adcval = adc->adc0->readSingle(); // read and clear interrupt,  dma occurs
}


//----------------------------------------------------------------------------------------------------
// EOS ISR;
//----------------------------------------------------------------------------------------------------

void EOS_isr(){

last_read = adcticks  -1;

//stop adc ops
dma0.disable();
adc->adc0->disableDMA();
adc->adc0->stopExtTrigPDB(true); 

spectrumReady = true; 

}


//----------------------------------------------------------------------------------------------------
// ST ISR
//----------------------------------------------------------------------------------------------------

void STfall_isr(){
    spectrumReady = false; 
    adcticks = 0;
    last_read = 0;

    adc->adc0->startExtTrigPDB(false); //to enable external trigger and its interrupt
    adc->adc0->startSingleRead(S_Video);
    adc->adc0->enableInterrupts(adc0_isr);

    adc->adc0->enableDMA();
    dma0.enable();
}



//----------------------------------------------------------------------------------------------------
// ADC DMA Setup
//----------------------------------------------------------------------------------------------------


// settings for adc

void setADC() {

    adc->adc0->disablePGA();
    adc->adc0->setReference(ADC_REFERENCE::REF_3V3);
    adc->adc0->setAveraging(0);
    adc->adc0->setResolution(12); //set the ADC resolution directly, not with AnalogReadResolution
    adc->adc0->disableCompare();


if (ADC_HS == true)
{
    adc->adc0->setConversionSpeed(ADC_CONVERSION_SPEED::VERY_HIGH_SPEED);
    adc->adc0->setSamplingSpeed(ADC_SAMPLING_SPEED::VERY_HIGH_SPEED);
} else {
    adc->adc0->setConversionSpeed(ADC_CONVERSION_SPEED::HIGH_SPEED);
    adc->adc0->setSamplingSpeed(ADC_SAMPLING_SPEED::HIGH_SPEED);

}

// initialize the DMA

dma0.source((volatile uint16_t&)ADC0_RA);
dma0.destinationBuffer(spectrum, sizeof(spectrum));
dma0.triggerAtHardwareEvent(DMAMUX_SOURCE_ADC0);
dma0.interruptAtCompletion();
dma0.disableOnCompletion();
dma0.attachInterrupt(&dma0_isr);
}

//----------------------------------------------------------------------------------------------------
// Data Transmission
//----------------------------------------------------------------------------------------------------


void transmitSpectrum(uint16_t *data) {
    size_t i; 

    for (i = 87 ; i < C12880_NCA+87; i++) //corrected values for loop start and finish
    {
        mySerial.printf("%d, ", data[i]);
    }
mySerial.write('\n');

}

//----------------------------------------------------------------------------------------------------
// GetMaxPWMFqz
//----------------------------------------------------------------------------------------------------

float GetMaxPWMFreqValue(uint32_t FREQ, uint16_t PWM_Resolution)
{
  /* for Teensy 3.x CPU frequency 24MHZ 48MHZ 72MHZ 96MHZ 120MHZ  */
  int FREQ_pointer=-1;
  float PWM_ideal_frequency[5][15]
  {
    { 6000000, 3000000, 1500000,  750000, 375000, 187500,  93750,  46875  , 23437.5 , 11718.75 ,  5859.375, 2929.687, 1464.843,  732.421, 366.2109},
    {12000000, 6000000, 3000000, 1500000, 750000, 375000, 187500,  93750  , 46875   , 23437.5  , 11718.75 , 5859.375, 2929.687, 1464.843, 732.4218},
    { 9000000, 4500000, 2250000, 1125000, 562500, 281250, 140625,  70312  , 35156.25, 17578.12 ,  8789.062, 4394.531, 2197.265, 1098.632, 549.3164},
    {12000000, 6000000, 3000000, 1500000, 750000, 375000, 187500,  93750  , 46875   , 23437.5  , 11718.75 , 5859.375, 2929.687, 1464.843, 732.4218},
    {15000000, 7500000, 3750000, 1875000, 937500, 468750, 234375, 117187.5, 58593.75, 29296.875, 14648.537, 7324.219, 3662.109, 1831.055, 915.527 }
  };
  switch(FREQ){
    case 24:  FREQ_pointer=0;  break;
    case 48:  FREQ_pointer=1;  break;
    case 72:  FREQ_pointer=2;  break; 
    case 96:  FREQ_pointer=3;  break; 
    case 120: FREQ_pointer=4;  break;          
    default:  FREQ_pointer=-1; break;          
  }
  if (FREQ_pointer >= 0) { return(PWM_ideal_frequency[FREQ_pointer][PWM_Resolution-2]); }
  else {                   return(488.28); }
} // end getMaxPWMFreqValue


//----------------------------------------------------------------------------------------------------
// Setup
//----------------------------------------------------------------------------------------------------

void setup () {
    while (millis() < 3000) ;
    mySerial.begin(BAUDRATE);
    mySerial.setTimeout(1);    


// set pins and pre states 

//out
pinMode(S_CLK, OUTPUT);
pinMode(S_ST, OUTPUT);

//in
pinMode(S_TRG, INPUT);
pinMode(S_Video, INPUT);
pinMode(S_EOS, INPUT);
pinMode(S_CCount, INPUT);

// states
digitalWriteFast(S_ST, LOW);
digitalWriteFast(S_CLK, LOW);


//ISR Trigg
attachInterrupt(S_CCount, CodeRunner, RISING);
attachInterrupt(S_EOS, EOS_isr, RISING);
attachInterrupt(S_ST, STfall_isr, FALLING);

// start the clk
CLK_gen();
setADC();

count = 1; 
myState = Holding;

}//end of setup




//----------------------------------------------------------------------------------------------------
// Loop
//----------------------------------------------------------------------------------------------------

void loop () {

    if((myState == Holding) && (spectrumReady == false)) {
        myState = preStart;
    }
    if (spectrumReady == true) {
       transmitSpectrum(spectrum);
       spectrumReady = false; 
       delay(100);

    }
}

